/*
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 *
 * This product includes software developed at Datadog (https://www.datadoghq.com)  Copyright 2024 Datadog, Inc.
 */

// Package scan implements functions and helpers to ensure the proper scan of the specified files
package scan

import (
	"context"

	"github.com/Checkmarx/kics/pkg/engine"
	"github.com/Checkmarx/kics/pkg/engine/provider"
	"github.com/Checkmarx/kics/pkg/engine/source"
	"github.com/Checkmarx/kics/pkg/kics"
	"github.com/Checkmarx/kics/pkg/logger"
	"github.com/Checkmarx/kics/pkg/model"
	"github.com/Checkmarx/kics/pkg/parser"
	ansibleConfigParser "github.com/Checkmarx/kics/pkg/parser/ansible/ini/config"
	ansibleHostsParser "github.com/Checkmarx/kics/pkg/parser/ansible/ini/hosts"
	bicepParser "github.com/Checkmarx/kics/pkg/parser/bicep"
	buildahParser "github.com/Checkmarx/kics/pkg/parser/buildah"
	protoParser "github.com/Checkmarx/kics/pkg/parser/grpc"
	terraformParser "github.com/Checkmarx/kics/pkg/parser/terraform"
	yamlParser "github.com/Checkmarx/kics/pkg/parser/yaml"
	"github.com/Checkmarx/kics/pkg/resolver"
	"github.com/Checkmarx/kics/pkg/scanner"
)

// Results represents a result generated by a single scan
type Results struct {
	Results        []model.Vulnerability
	ExtractedPaths provider.ExtractedPath
	Files          model.FileMetadatas
	FailedQueries  map[string]error
}

type executeScanParameters struct {
	services       []*kics.Service
	inspector      *engine.Inspector
	extractedPaths provider.ExtractedPath
}

func (c *Client) initScan(ctx context.Context) (*executeScanParameters, error) {
	logger := logger.FromContext(ctx)
	progressBar := c.ProBarBuilder.BuildCircle("Preparing Scan Assets: ")
	go progressBar.Start(ctx)

	extractedPaths, err := c.prepareAndAnalyzePaths(ctx)
	if err != nil {
		logger.Err(err).Msgf("failed to prepare and analyze paths %v", err)
		return nil, err
	}

	if len(extractedPaths.Path) == 0 {
		return nil, nil
	}

	paramsPlatforms := c.ScanParams.Platform
	useDifferentPlatformQueries(&paramsPlatforms)
	querySource := source.NewFilesystemSource(
		ctx,
		c.ScanParams.QueriesPath,
		paramsPlatforms,
		c.ScanParams.CloudProvider,
		c.ScanParams.LibrariesPath,
		c.ScanParams.ExperimentalQueries)

	queryFilter := c.createQueryFilter()

	logger.Info().Msgf("Preparing to inspect query source %v", querySource)

	inspector, err := engine.NewInspector(ctx,
		querySource,
		engine.DefaultVulnerabilityBuilder,
		c.Tracker,
		queryFilter,
		c.ExcludeResultsMap,
		c.ScanParams.QueryExecTimeout,
		c.ScanParams.UseOldSeverities,
		true,
		c.ScanParams.ParallelScanFlag,
		c.ScanParams.KicsComputeNewSimID,
		c.ScanParams.FeatureFlags,
	)
	if err != nil {
		return nil, err
	}

	logger.Info().Msgf("Finshed inspect query source %v", querySource)

	// secretsRegexRulesContent, err := getSecretsRegexRules(c.ScanParams.SecretsRegexesPath)
	// if err != nil {
	// 	return nil, err
	// }

	// isCustomSecretsRegexes := c.ScanParams.SecretsRegexesPath != ""

	// secretsInspector, err := secrets.NewInspector(
	// 	ctx,
	// 	c.ExcludeResultsMap,
	// 	c.Tracker,
	// 	queryFilter,
	// 	c.ScanParams.DisableSecrets,
	// 	c.ScanParams.QueryExecTimeout,
	// 	secretsRegexRulesContent,
	// 	isCustomSecretsRegexes,
	// )
	// if err != nil {
	// 	logger.Err(err)
	// 	return nil, err
	// }

	services, err := c.createService(
		ctx,
		inspector,
		extractedPaths.Path,
		c.Tracker,
		c.Storage,
		querySource,
	)
	if err != nil {
		logger.Err(err).Msgf("failed to create service %v", err)
		return nil, err
	}

	if err := progressBar.Close(); err != nil {
		logger.Debug().Msgf("Failed to close progress bar: %s", err.Error())
	}

	return &executeScanParameters{
		services:       services,
		inspector:      inspector,
		extractedPaths: extractedPaths,
	}, nil
}

func (c *Client) executeScan(ctx context.Context) (*Results, error) {
	logger := logger.FromContext(ctx)
	executeScanParameters, err := c.initScan(ctx)

	if err != nil {
		logger.Err(err).Msgf("failed to execute scan %v", err)
		return nil, err
	}

	if executeScanParameters == nil {
		return nil, nil
	}

	logger.Info().Msg("Scan initialized")

	logger.Info().Msgf("Preparing to scan")

	if err = scanner.PrepareAndScan(
		ctx,
		c.ScanParams.ScanID, c.ScanParams.OpenAPIResolveReferences, c.ScanParams.MaxResolverDepth, *c.ProBarBuilder,
		executeScanParameters.services); err != nil {
		logger.Err(err).Msgf("failed to prepare and scan %v", err)
		return nil, err
	}

	logger.Info().Msg("Scan finished")

	failedQueries := executeScanParameters.inspector.GetFailedQueries()

	results, err := c.Storage.GetVulnerabilities(ctx, c.ScanParams.ScanID)
	if err != nil {
		logger.Err(err).Msgf("failed to get vulns %v", err)
		return nil, err
	}

	files, err := c.Storage.GetFiles(ctx, c.ScanParams.ScanID)
	if err != nil {
		logger.Err(err).Msgf("failed to get files %v", err)
		return nil, err
	}

	return &Results{
		Results:        results,
		ExtractedPaths: executeScanParameters.extractedPaths,
		Files:          files,
		FailedQueries:  failedQueries,
	}, nil
}

func useDifferentPlatformQueries(platforms *[]string) {
	hasBicep := false
	hasARM := false
	for _, platform := range *platforms {
		if platform == "bicep" {
			hasBicep = true
		}
		if platform == "azureresourcemanager" {
			hasARM = true
		}
		if hasARM && hasBicep {
			break
		}
	}

	if hasBicep && !hasARM {
		*platforms = append(*platforms, "azureresourcemanager")
	}
}

func getExcludeResultsMap(excludeResults []string) map[string]bool {
	excludeResultsMap := make(map[string]bool)
	for _, er := range excludeResults {
		excludeResultsMap[er] = true
	}
	return excludeResultsMap
}

// func getSecretsRegexRules(regexRulesPath string) (regexRulesContent string, err error) {
// 	if regexRulesPath != "" {
// 		b, err := os.ReadFile(regexRulesPath)
// 		if err != nil {
// 			return regexRulesContent, err
// 		}
// 		regexRulesContent = string(b)
// 	} else {
// 		regexRulesContent = assets.SecretsQueryRegexRulesJSON
// 	}

// 	return regexRulesContent, nil
// }

func (c *Client) createQueryFilter() *source.QueryInspectorParameters {
	excludeQueries := source.ExcludeQueries{
		ByIDs:        c.ScanParams.ExcludeQueries,
		ByCategories: c.ScanParams.ExcludeCategories,
		BySeverities: c.ScanParams.ExcludeSeverities,
	}

	includeQueries := source.IncludeQueries{
		ByIDs: c.ScanParams.IncludeQueries,
	}

	queryFilter := source.QueryInspectorParameters{
		IncludeQueries:      includeQueries,
		ExcludeQueries:      excludeQueries,
		ExperimentalQueries: c.ScanParams.ExperimentalQueries,
		InputDataPath:       c.ScanParams.InputData,
		BomQueries:          c.ScanParams.BillOfMaterials,
		FlagEvaluator:       c.FlagEvaluator,
	}

	return &queryFilter
}

func (c *Client) createService(
	ctx context.Context,
	inspector *engine.Inspector,
	paths []string,
	t kics.Tracker,
	store kics.Storage,
	querySource *source.FilesystemSource) ([]*kics.Service, error) {
	filesSource, err := c.getFileSystemSourceProvider(ctx, paths)
	if err != nil {
		return nil, err
	}

	combinedParser, err := parser.NewBuilder(ctx).
		// Add(&jsonParser.Parser{}).
		Add(&yamlParser.Parser{}).
		Add(terraformParser.NewDefaultWithParams(c.ScanParams.TerraformVarsPath, c.ScanParams.SCIInfo)).
		Add(&bicepParser.Parser{}).
		Add(&protoParser.Parser{}).
		Add(&buildahParser.Parser{}).
		Add(&ansibleConfigParser.Parser{}).
		Add(&ansibleHostsParser.Parser{}).
		Build(querySource.Types, querySource.CloudProviders)
	if err != nil {
		return nil, err
	}

	// combinedResolver to be used to resolve files and templates
	combinedResolver, err := resolver.NewBuilder().
		Build(ctx)
	if err != nil {
		return nil, err
	}

	services := make([]*kics.Service, 0, len(combinedParser))

	for _, parser := range combinedParser {
		services = append(
			services,
			&kics.Service{
				SourceProvider: filesSource,
				Storage:        store,
				Parser:         parser,
				Inspector:      inspector,
				Tracker:        t,
				Resolver:       combinedResolver,
				MaxFileSize:    c.ScanParams.MaxFileSizeFlag,
			},
		)
	}
	return services, nil
}

func (c *Client) getFileSystemSourceProvider(ctx context.Context, paths []string) (*provider.FileSystemSourceProvider, error) {
	var excludePaths []string
	if c.ScanParams.PayloadPath != "" {
		excludePaths = append(excludePaths, c.ScanParams.PayloadPath)
	}

	if len(c.ScanParams.ExcludePaths) > 0 {
		excludePaths = append(excludePaths, c.ScanParams.ExcludePaths...)
	}

	filesSource, err := provider.NewFileSystemSourceProvider(ctx, paths, excludePaths)
	if err != nil {
		return nil, err
	}
	return filesSource, nil
}
