/*
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 *
 * This product includes software developed at Datadog (https://www.datadoghq.com)  Copyright 2024 Datadog, Inc.
 */
package engine

import (
	"context"
	"encoding/json"
	"fmt"
	"strings"
	"time"

	dec "github.com/Checkmarx/kics/pkg/detector"
	"github.com/Checkmarx/kics/pkg/engine/similarity"
	"github.com/Checkmarx/kics/pkg/featureflags"
	"github.com/Checkmarx/kics/pkg/logger"
	"github.com/Checkmarx/kics/pkg/model"
	"github.com/pkg/errors"
	"github.com/rs/zerolog"
)

const (
	formatFloat64   = 64
	searchKeyMinLen = 3
)

func modifyVulSearchKeyReference(doc interface{}, originalSearchKey string, stringVulList []string) (string, bool) {
	for index, vulSplit := range stringVulList {
		switch docTyped := doc.(type) {
		case map[string]interface{}:
			if strings.HasPrefix(vulSplit, "{{") && strings.HasSuffix(vulSplit, "}}") {
				vulSplit = vulSplit[2 : len(vulSplit)-2]
			}
			if vulSplitEqual := strings.Split(vulSplit, "="); len(vulSplitEqual) != 1 {
				vulSplit = vulSplitEqual[0]
			}
			newDoc, foundEntry := docTyped[vulSplit]
			if metadataRefDoc, ok := docTyped["RefMetadata"]; ok && foundEntry && index < len(stringVulList) {
				newSearchKey := strings.Join(stringVulList[:index], ".") + ".$ref=" + (metadataRefDoc.(map[string]interface{})["$ref"].(string))
				return newSearchKey, true
			} else if foundEntry {
				doc = newDoc
			} else {
				return originalSearchKey, false
			}
		case []interface{}:
			for _, listDoc := range docTyped {
				if newSearchKey, modified := modifyVulSearchKeyReference(listDoc, originalSearchKey, stringVulList[index:]); modified {
					return strings.Join(stringVulList[:index], ".") + "." + newSearchKey, true
				}
			}
			return originalSearchKey, false
		default:
			if index != len(stringVulList)-1 {
				return originalSearchKey, false
			}
		}
	}
	return originalSearchKey, false
}

// DefaultVulnerabilityBuilder defines a vulnerability builder to execute default actions of scan
var DefaultVulnerabilityBuilder = func(ctx context.Context, qCtx *QueryContext,
	tracker Tracker,
	v interface{},
	detector *dec.DetectLine,
	useOldSeverities bool,
	kicsComputeNewSimID bool,
	queryDuration time.Duration) (*model.Vulnerability, error) {
	logger := logger.FromContext(ctx)
	vObj, ok := v.(map[string]interface{})
	if !ok {
		return &model.Vulnerability{}, ErrInvalidResult
	}

	vObj = mergeWithMetadata(vObj, qCtx.Query.Metadata.Metadata)

	var err error
	var output []byte

	output, err = json.Marshal(vObj)
	if err != nil {
		return &model.Vulnerability{}, errors.Wrap(err, "failed to marshall query output")
	}

	var fileID *string

	fileID, err = mapKeyToString(ctx, vObj, "documentId", false)
	if err != nil {
		return &model.Vulnerability{}, errors.Wrap(err, "failed to recognize file id")
	}

	file, ok := qCtx.Files[*fileID]
	if !ok {
		return &model.Vulnerability{}, errors.New("failed to find file from query response")
	}

	logWithFields := logger.With().
		Str("scanID", qCtx.scanID).
		Str("fileName", file.FilePath).
		Str("queryName", qCtx.Query.Metadata.Query).
		Logger()

	detector.SetupLogs(&logWithFields)

	linesVulne := model.VulnerabilityLines{
		Line:                  -1,
		VulnLines:             &[]model.CodeLine{},
		LineWithVulnerability: "",
	}

	similarityIDLineInfo := ""
	searchKey := ""
	if s, ok := vObj["searchKey"]; ok {
		searchKey = s.(string)
		similarityIDLineInfo = searchKey
		intDoc := file.LineInfoDocument
		vulsSplit := strings.Split(searchKey, ".")

		if file.Kind == model.KindINI {
			vulsSplit, searchKey = sanitizeINIKey(vulsSplit)
		}

		if strings.Contains(vulsSplit[len(vulsSplit)-1], "RefMetadata") {
			return &model.Vulnerability{}, ErrNoResult
		}

		// modify the search key in cases where it should be referencing a ref instead of part of the resolved object
		searchKey, _ = modifyVulSearchKeyReference(intDoc, searchKey, vulsSplit)
		vObj["searchKey"] = searchKey
		linesVulne = detector.DetectLine(ctx, &file, searchKey)
	} else {
		logWithFields.Error().Msg("Saving result. failed to detect line")
	}

	lineNumber := 0
	var similarityIDLineInfoOld = similarityIDLineInfo
	if file.Kind != model.KindHELM && len(file.ResolvedFiles) == 0 {
		searchLineCalc := &searchLineCalculator{
			lineNr:               -1,
			vObj:                 vObj,
			file:                 file,
			detector:             detector,
			similarityIDLineInfo: similarityIDLineInfo,
			linesVulne:           linesVulne,
		}
		// calculate search Line if possible (default uses values of search key)
		lineNumber, similarityIDLineInfoOld, linesVulne = calculeSearchLine(ctx, searchLineCalc)
	}

	if linesVulne.Line == -1 {
		logWithFields.Warn().Msgf("Failed to detect line, query response %s", searchKey)
		linesVulne.Line = 1
	}

	searchValue := ""
	if s, ok := vObj["searchValue"]; ok {
		searchValue = s.(string)
	}

	overrideKey := ""
	if s, ok := vObj["overrideKey"]; ok {
		overrideKey = s.(string)
	}

	queryID := getStringFromMap(ctx, "id", DefaultQueryID, overrideKey, vObj, &logWithFields)

	severity := getResolvedSeverity(ctx, vObj, &logWithFields, overrideKey, useOldSeverities)

	issueType := DefaultIssueType
	if v := mustMapKeyToString(ctx, vObj, "issueType"); v != nil {
		issueType = model.IssueType(*v)
	}

	similarityID, oldSimilarityID := generateSimilaritiesID(ctx, qCtx, linesVulne.ResolvedFile, queryID, similarityIDLineInfo, searchValue,
		searchKey, similarityIDLineInfoOld, kicsComputeNewSimID, &logWithFields, tracker)

	return &model.Vulnerability{
		ID:              0,
		SimilarityID:    PtrStringToString(similarityID),
		OldSimilarityID: PtrStringToString(oldSimilarityID),
		ScanID:          qCtx.scanID,
		FileID:          file.ID,
		FileName:        linesVulne.ResolvedFile,
		QueryName:       getStringFromMap(ctx, "queryName", DefaultQueryName, overrideKey, vObj, &logWithFields),
		QueryID:         queryID,
		Experimental:    getBoolFromMap(ctx, "experimental", DefaultExperimental, overrideKey, vObj, &logWithFields),
		QueryURI:        getStringFromMap(ctx, "descriptionUrl", DefaultQueryURI, overrideKey, vObj, &logWithFields),
		Category:        getStringFromMap(ctx, "category", "", overrideKey, vObj, &logWithFields),
		Description:     getStringFromMap(ctx, "descriptionText", "", overrideKey, vObj, &logWithFields),
		DescriptionID:   getStringFromMap(ctx, "descriptionID", DefaultQueryDescriptionID, overrideKey, vObj, &logWithFields),
		Severity:        severity,
		Platform:        getStringFromMap(ctx, "platform", "", overrideKey, vObj, &logWithFields),
		CWE:             getStringFromMap(ctx, "cwe", "", overrideKey, vObj, &logWithFields),
		Line:            linesVulne.Line,
		VulnerabilityLocation: model.ResourceLocation{
			Start: linesVulne.VulnerablilityLocation.Start,
			End:   linesVulne.VulnerablilityLocation.End,
		},
		RemediationLocation: model.ResourceLocation{
			Start: linesVulne.RemediationLocation.Start,
			End:   linesVulne.RemediationLocation.End,
		},
		VulnLines:             linesVulne.VulnLines,
		ResourceType:          PtrStringToString(mustMapKeyToString(ctx, vObj, "resourceType")),
		ResourceName:          PtrStringToString(mustMapKeyToString(ctx, vObj, "resourceName")),
		IssueType:             issueType,
		SearchKey:             searchKey,
		SearchLine:            lineNumber,
		SearchValue:           searchValue,
		KeyExpectedValue:      PtrStringToString(mustMapKeyToString(ctx, vObj, "keyExpectedValue")),
		KeyActualValue:        PtrStringToString(mustMapKeyToString(ctx, vObj, "keyActualValue")),
		Value:                 mustMapKeyToString(ctx, vObj, "value"),
		Output:                string(output),
		CloudProvider:         getCloudProvider(ctx, overrideKey, vObj, &logWithFields),
		Remediation:           PtrStringToString(mustMapKeyToString(ctx, vObj, "remediation")),
		RemediationType:       PtrStringToString(mustMapKeyToString(ctx, vObj, "remediationType")),
		QueryDuration:         queryDuration,
		LineWithVulnerability: linesVulne.LineWithVulnerability,
		ResourceSource:        linesVulne.ResourceSource,
		FileSource:            linesVulne.FileSource,
		BlockLocation:         linesVulne.BlockLocation,
		Frameworks:            append(extractDefaultFrameworks(ctx, qCtx.Query.Metadata.Metadata, qCtx.FlagEvaluator), extractCustomFrameworks(ctx, qCtx.Query.Metadata.Metadata, qCtx.FlagEvaluator)...),
	}, nil
}

func extractDefaultFrameworks(ctx context.Context, metadata map[string]interface{}, flagEvaluator featureflags.FlagEvaluator) []model.Framework {
	log := logger.FromContext(ctx)

	frameworksData, exists := metadata["defaultFrameworks"]
	if !exists {
		return []model.Framework{}
	}

	if !flagEvaluator.EvaluateWithOrg(featureflags.IacAttachDefaultFrameworks) {
		log.Info().Msg("Skipping default framework attachment")
		return []model.Framework{}
	}

	return extractFrameworks(ctx, frameworksData)
}

func extractCustomFrameworks(ctx context.Context, metadata map[string]interface{}, flagEvaluator featureflags.FlagEvaluator) []model.Framework {
	log := logger.FromContext(ctx)

	frameworksData, exists := metadata["customFrameworks"]
	if !exists {
		return []model.Framework{}
	}

	if !flagEvaluator.EvaluateWithOrg(featureflags.IacAttachCustomFrameworks) {
		log.Info().Msg("Skipping custom framework attachment")
		return []model.Framework{}
	}

	return extractFrameworks(ctx, frameworksData)
}

func extractFrameworks(ctx context.Context, frameworksData interface{}) []model.Framework {
	log := logger.FromContext(ctx)
	var frameworks []model.Framework
	frameworksSlice, ok := frameworksData.([]interface{})
	if !ok {
		log.Error().Msg(fmt.Sprintf("Framework definition corrupted, skipping %v", frameworksData))
		return []model.Framework{}
	}

	for _, fw := range frameworksSlice {
		frameworkMap, ok := fw.(map[string]interface{})
		if !ok {
			log.Error().Msg(fmt.Sprintf("Framework definition corrupted, skipping %v", fw))
			continue
		}

		log.Info().Msg(fmt.Sprintf("Attaching framework: %v", frameworkMap))
		framework := model.Framework{
			Framework:        getString(frameworkMap, "framework"),
			FrameworkVersion: getString(frameworkMap, "framework_version"),
			Requirement:      getString(frameworkMap, "requirement"),
			Control:          getString(frameworkMap, "control"),
		}
		frameworks = append(frameworks, framework)
	}

	return frameworks
}

func getString(m map[string]interface{}, key string) string {
	if val, exists := m[key]; exists {
		if str, ok := val.(string); ok {
			return str
		}
	}
	return ""
}

// <editor-fold desc="similarity id">
func generateSimilaritiesID(
	ctx context.Context, qCtx *QueryContext,
	resolvedFile, queryID, similarityIDLineInfo, searchValue, searchKey, similarityIDLineInfoOld string,
	kicsComputeNewSimID bool,
	logWithFields *zerolog.Logger,
	tracker Tracker) (similarityID, oldSimilarityID *string) {
	if kicsComputeNewSimID {
		similarityID, err := buildSimilarityID(ctx, qCtx, resolvedFile, queryID, similarityIDLineInfo, searchValue)
		if err != nil {
			logWithFields.Err(err).Send()
			tracker.FailedComputeSimilarityID()
		}

		oldSimilarityID, err = oldBuildSimilarityID(ctx, qCtx, resolvedFile, queryID, searchKey, similarityIDLineInfoOld, searchValue)
		if err != nil {
			logWithFields.Err(err).Send()
			tracker.FailedComputeOldSimilarityID()
		}
		return similarityID, oldSimilarityID
	} else {
		similarityID, err := oldBuildSimilarityID(ctx, qCtx, resolvedFile, queryID, searchKey, similarityIDLineInfoOld, searchValue)
		if err != nil {
			logWithFields.Err(err).Send()
			tracker.FailedComputeSimilarityID()
		}
		return similarityID, oldSimilarityID
	}
}

func buildSimilarityID(
	ctx context.Context,
	qCtx *QueryContext,
	resolvedFile,
	queryID,
	searchKey,
	searchValue string) (*string, error) {
	return similarity.ComputeSimilarityID(ctx, qCtx.BaseScanPaths, resolvedFile, queryID, searchKey, searchValue)
}

// <editor-fold desc="old similarity id">
func oldBuildSimilarityID(
	ctx context.Context,
	qCtx *QueryContext,
	resolvedFile,
	queryID,
	searchKey,
	similarityIDLineInfo,
	searchValue string) (*string, error) {
	if checkMinified(qCtx, resolvedFile) {
		return similarity.ComputeSimilarityID(ctx, qCtx.BaseScanPaths, resolvedFile, queryID, searchKey, searchValue)
	} else {
		return similarity.ComputeSimilarityID(ctx, qCtx.BaseScanPaths, resolvedFile, queryID, similarityIDLineInfo, searchValue)
	}
}

func checkMinified(ctx *QueryContext, resolvedFile string) bool {
	for i := range ctx.Files {
		if ctx.Files[i].FilePath == resolvedFile {
			return ctx.Files[i].IsMinified
		}
	}
	return false
}

// </editor-fold>
// </editor-fold>

func getCloudProvider(ctx context.Context, overrideKey string, vObj map[string]interface{}, logWithFields *zerolog.Logger) string {
	cloudProvider := ""
	if _, ok := vObj["cloudProvider"]; ok {
		cloudProvider = getStringFromMap(ctx, "cloudProvider", "", overrideKey, vObj, logWithFields)
	}
	return cloudProvider
}

// calculate search Line if possible (default uses values of search key)
func calculeSearchLine(ctx context.Context, searchLineCalc *searchLineCalculator) (lineNumber int,
	similarityIDLineInfo string, linesVulne model.VulnerabilityLines) {
	searchLineCalc.calculate(ctx)
	lineNumber = searchLineCalc.lineNr
	similarityIDLineInfo = searchLineCalc.similarityIDLineInfo
	linesVulne = searchLineCalc.linesVulne

	return lineNumber, similarityIDLineInfo, linesVulne
}

func getResolvedSeverity(ctx context.Context, vObj map[string]interface{}, logWithFields *zerolog.Logger,
	overrideKey string, useOldSeverities bool) model.Severity {
	var severity model.Severity = model.SeverityInfo
	s, err := mapKeyToString(ctx, vObj, "severity", false)

	if err == nil {
		sev := getSeverity(strings.ToUpper(*s))
		if sev == "" {
			logWithFields.Warn().Str("severity", *s).Msg("Saving result. invalid severity constant value")
		} else {
			severity = sev
			overrideValue := tryOverride(ctx, overrideKey, "severity", vObj)
			if overrideValue != nil {
				sev = getSeverity(strings.ToUpper(*overrideValue))
				if sev != "" {
					severity = sev
				}
			} else if useOldSeverities {
				oldS, errOld := mapKeyToString(ctx, vObj, "oldSeverity", false)
				if errOld == nil {
					oldSev := getSeverity(strings.ToUpper(*oldS))
					severity = oldSev
				}
			}
		}
	} else {
		logWithFields.Info().Msg("Saving result. failed to detect severity")
	}

	return severity
}

// sanitizeINIKey removes useless searchkey elements like "all" and "children"
func sanitizeINIKey(vulsSplit []string) (vulsRefact []string, searchKey string) {
	length := len(vulsSplit)
	vulsRefact = vulsSplit
	if length >= searchKeyMinLen {
		vulsRefact = []string{"[" + vulsSplit[2] + "]"}

		if length >= searchKeyMinLen+2 {
			vulsRefact = append(vulsRefact, vulsSplit[4])

			if length >= searchKeyMinLen+4 {
				vulsRefact = append(vulsRefact, vulsSplit[6])
			}
		}
	}
	return vulsRefact, strings.Join(vulsRefact, ".")
}
