/*
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache-2.0 License.
 *
 * This product includes software developed at Datadog (https://www.datadoghq.com)  Copyright 2024 Datadog, Inc.
 */
package engine

import (
	"context"
	"encoding/json"
	"fmt"
	"strconv"

	dec "github.com/Checkmarx/kics/pkg/detector"
	"github.com/Checkmarx/kics/pkg/model"
	"github.com/Checkmarx/kics/pkg/utils"
	"github.com/rs/zerolog"
	"github.com/rs/zerolog/log"
)

type searchLineCalculator struct {
	lineNr               int
	vObj                 map[string]interface{}
	file                 model.FileMetadata
	detector             *dec.DetectLine
	similarityIDLineInfo string
	linesVulne           model.VulnerabilityLines
}

func (s *searchLineCalculator) calculate(ctx context.Context) {
	logger := log.Ctx(ctx)
	if searchLine, ok := s.vObj["searchLine"]; ok {
		line := make([]string, 0, len(searchLine.([]interface{})))
		for _, strElement := range searchLine.([]interface{}) {
			line = append(line, strElement.(string))
		}
		var err error
		s.lineNr, err = dec.GetLineBySearchLine(line, &s.file)
		if err != nil {
			logger.Error().Msgf("failed to get line information from searchLine, using searchKey")
		}
		if s.lineNr >= 0 {
			s.similarityIDLineInfo = strconv.Itoa(s.lineNr)
			resourceLocation := s.linesVulne.VulnerablilityLocation
			// s.linesVulne = s.detector.GetAdjacent(&s.file, s.lineNr)
			s.linesVulne.VulnerablilityLocation = resourceLocation
		}
	}
}
func mergeWithMetadata(base, additional map[string]interface{}) map[string]interface{} {
	for k, v := range additional {
		if _, ok := base[k]; ok {
			continue
		}
		base[k] = v
	}
	return base
}
func mustMapKeyToString(ctx context.Context, m map[string]interface{}, key string, qCtx ...*QueryContext) *string {
	logger := log.Ctx(ctx)
	var res *string
	var err error
	if len(qCtx) > 0 {
		res, err = mapKeyToString(ctx, m, key, true, qCtx...)
	} else {
		res, err = mapKeyToString(ctx, m, key, true)
	}
	excludedFields := []string{"value", "resourceName", "resourceType", "remediation", "remediationType"}
	if err != nil && !utils.Contains(key, excludedFields) {
		logger.Warn().
			Str("reason", err.Error()).
			Msgf("Failed to get key %s in map", key)
	}
	return res
}
func mapKeyToString(ctx context.Context, m map[string]interface{}, key string, allowNil bool, qCtx ...*QueryContext) (*string, error) {
	logger := log.Ctx(ctx)
	v, ok := m[key]
	if !ok {
		var err error
		if len(qCtx) > 0 {
			err = fmt.Errorf("key '%s' not found in map for query %s", key, qCtx[0].Query.Metadata.Query)
		} else {
			err = fmt.Errorf("key '%s' not found in map", key)
		}
		logger.Error().Msg(err.Error())
		return nil, err
	}
	switch vv := v.(type) {
	case json.Number:
		return stringToPtrString(vv.String()), nil
	case string:
		return stringToPtrString(vv), nil
	case int, int32, int64:
		return stringToPtrString(fmt.Sprintf("%d", vv)), nil
	case float32:
		return stringToPtrString(strconv.FormatFloat(float64(vv), 'f', -1, formatFloat64)), nil
	case float64:
		return stringToPtrString(strconv.FormatFloat(vv, 'f', -1, formatFloat64)), nil
	case nil:
		if allowNil {
			return nil, nil
		}
		return stringToPtrString("null"), nil
	case bool:
		return stringToPtrString(fmt.Sprintf("%v", vv)), nil
	}
	logger.Debug().
		Msg("Detecting line. can't format item to string")
	if allowNil {
		return nil, nil
	}
	return stringToPtrString(""), nil
}
func stringToPtrString(v string) *string {
	return &v
}

// PtrStringToString - converts a pointer to string to a string
func PtrStringToString(v *string) string {
	if v == nil {
		return ""
	}
	return *v
}
func tryOverride(ctx context.Context, overrideKey, vulnParam string, vObj map[string]interface{}) *string {
	if overrideKey != "" {
		if override, ok := vObj["override"].(map[string]interface{}); ok {
			if overrideObject, ok := override[overrideKey].(map[string]interface{}); ok {
				if _, ok := overrideObject[vulnParam]; ok {
					overrideValue, err := mapKeyToString(ctx, overrideObject, vulnParam, true)
					if err != nil {
						return nil
					} else if overrideValue != nil {
						return overrideValue
					}
				}
			}
		}
	}
	return nil
}
func getStringFromMap(ctx context.Context, vulnParam, defaultParam, overrideKey string, vObj map[string]interface{}, logWithFields *zerolog.Logger) string {
	ts, err := mapKeyToString(ctx, vObj, vulnParam, false)
	if err != nil {
		logWithFields.Err(err).
			Msgf("Saving result. failed to detect %s", vulnParam)
		return defaultParam
	}
	overrideValue := tryOverride(ctx, overrideKey, vulnParam, vObj)
	if overrideValue != nil {
		ts = overrideValue
	}
	return *ts
}
func getBoolFromMap(
	ctx context.Context,
	vulnParam string,
	defaultParam bool,
	overrideKey string,
	vObj map[string]interface{},
	logWithFields *zerolog.Logger) bool {
	ts, err := mapKeyToString(ctx, vObj, vulnParam, false)
	if err != nil {
		return defaultParam
	}
	overrideValue := tryOverride(ctx, overrideKey, vulnParam, vObj)
	if overrideValue != nil {
		ts = overrideValue
	}
	res, err := strconv.ParseBool(*ts)
	if err != nil {
		logWithFields.Err(err).
			Msgf("Saving result. failed to detect %s", vulnParam)
		return defaultParam
	}
	return res
}
func getSeverity(severity string) model.Severity {
	for _, si := range model.AllSeverities {
		if severity == string(si) {
			return si
		}
	}
	return ""
}
